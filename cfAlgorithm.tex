\documentclass[11pt, oneside]{amsart}   	% use "amsart" instead of "article" for AMSLaTeX format
\usepackage{geometry}                		% See geometry.pdf to learn the layout options. There are lots.
\geometry{letterpaper}                   		% ... or a4paper or a5paper or ... 
%\geometry{landscape}                		% Activate for rotated page geometry
%\usepackage[parfill]{parskip}    		% Activate to begin paragraphs with an empty line rather than an indent
\usepackage{graphicx}				% Use pdf, png, jpg, or epsÂ§ with pdflatex; use eps in DVI mode
								% TeX will automatically convert eps --> pdf in pdflatex		
\usepackage{amssymb}
\usepackage{algorithmic}
\usepackage{hyperref}
%SetFonts
%SetFonts
\newcommand{\pqrs}{\left(
\begin{smallmatrix} 
p & q\\ 
r & s 
\end{smallmatrix}
\right)}

\newcommand{\homographic}[4]{\begin{pmatrix} #1 & #2\\ #3 & #4 \end{pmatrix}}
\newcommand{\bihomographic}[8]{\left(\begin{smallmatrix}#1&#2&#3&#4\\#5&#6&#7&#8\end{smallmatrix}\right)}
\newcommand{\bihom}[8]{{\frac{#1 xy + #2 x + #3 y + #4}{#5 xy + #6 x + #7 y + #8}}}

\newcommand{\abcd}{\left(
\begin{smallmatrix} 
a & b & c & d\\ 
e & f & g & h
\end{smallmatrix}
\right)}

\title{Arithmetic on Continued Fractions}
\author{Michael J. Collins\\Associate Research Scientist\\Daniel H. Wagner Associates\\Hampton, VA USA\\mjcollins10@gmail.com}
%\date{} % Activate to display a given date or no date

\begin{document}
\maketitle

\section{Introduction}
A continued fraction is a (possibly infinite) expression of the form
\begin{equation*}
a_0+\cfrac{1}{a_1+\cfrac{1}{a_2+\cfrac{1}{a_3+\cdots}}}
\end{equation*}
where the terms $a_i$ are integers, with $a_i$ positive when $i>0$. It is written more compactly as $[a_0, a_1, \cdots]$. The properties of continued fractions are very well-known\footnote{\href{https://en.wikipedia.org/wiki/Simple\_continued\_fraction}{https://en.wikipedia.org/wiki/Simple\_continued\_fraction}}, so here we only remind the reader of some notation we will use:
\begin{itemize}
\item A quadratic irrational has a periodic CF expansion. We denote the periodic part by putting it in parentheses, i.e $[1,(2,3)] = [1,2,3,2,3,2,3,\cdots]$.
\item A rational number has a finite CF expansion $[a_0,a_1\cdots a_k]$. It will be convenient to consider a finite CF as ending with an infinite term $a_{k+1}=\infty$, treating $\frac{1}{\infty}$ as equal to zero.
\end{itemize}
 
Gosper (in an appendix to the famous HAKMEM\footnote{\href{https://dspace.mit.edu/handle/1721.1/6086}{https://dspace.mit.edu/handle/1721.1/6086}} report)  developed algorithms for adding, subtracting, multiplying, or dividing two CFs, and for solving quadratics with CF coefficients, getting a CF as the result\footnote{\href{https://perl.plover.com/classes/cftalk/INFO/gosper.html}{https://perl.plover.com/classes/cftalk/INFO/gosper.html}}; the point of course is that we can do this entirely within the CF representation, making no use of floating-point arithmetic. Here we present modified versions of those algorithms which avoid all difficulties with infinite loops; any combination of arithmetic computations can be carried out to any required degree of accuracy in a finite number of steps. We have implemented these algorithms in Haskell\footnote{\href{https://github.com/mjcollins10/ContinuedFractions}{https://github.com/mjcollins10/ContinuedFractions}}.

%https://github.com/themadcreator/gosper-rs
\section{Arithmetic on One CF}
Before we describe how to add or multiply two CFs, we consider the simpler problem of operations combining a single CF with a rational number $p/q$. A few examples reveal there is no evident general pattern for transforming the CF terms of irrational $x$ into the terms of $px/q$ or $x + p/q$, even in the apparently simplest cases:
\begin{eqnarray*}
\sqrt{7} & = & [2, (1, 1, 1, 4)] \\
\sqrt{7}/2 & = & [1, (3, 10, 3, 2)] \\
\sqrt{11} & = & [3, (3, 6)] \\
\sqrt{11}/2 & = & [1, (1, 1, 1, 12, 1, 1, 1, 2)] \\
\pi & = & [3,7,15,1,292,1,1,1, 2, 1, 3,\cdots]\\
\pi + 1/2 & = & [3, 1, 1, 1, 3, 1, 3, 4, 73, 6, 3, 3, 2, 1, 3\cdots]
\end{eqnarray*}
As a motivating example for the general algorithm, we compute
\[[y_0,y_1,y_2 \cdots] = \pi/2 = 1.5707963267948966\cdots\ .
\]
It will be convenient to have notation for the ``tail" of a continued fraction, so let
\[
r_i = [\pi_{i+1}, \pi_{i+2},\cdots]\ .
\]
Note that all $r_i \geq 1$, and $r_i = \pi_{i+1} + 1/r_{i+1}$. The fact that $\pi_0 = \lfloor \pi \rfloor= 3$ is enough to determine $y_0=\lfloor \pi/2 \rfloor=1$; more precisely
\begin{equation}
y = \frac{\pi}{2} = \frac{3 + 1/r_0}{2} = \frac{3r_0+1}{2r_0} = 1 + \frac{r_0+1}{2r_0}= 1 + \frac{1}{[y_1,y_2,\cdots]}\ .
\end{equation}
Now we have to get $y_1$ from 
\begin{equation}
[y_1,y_2,\cdots] = \frac{2r_0}{r_0+1}\ .
\end{equation}
The mere fact that $r_0>1$ is enough to tell us that $\lfloor \frac{2r_0}{r_0+1} \rfloor = 1$, so we obtain $y_1=1$ and continue
\begin{equation}
[y_1,y_2,\cdots] = 1 + \frac{r_0-1}{r_0+1} = y_1 + \frac{1}{[y_2,y_3\cdots]}
\end{equation}
\begin{equation}
[y_2,\cdots] = \frac{r_0+1}{r_0-1} \ .
\end{equation}
Now the floor of $\frac{r_0+1}{r_0-1}$ ranges from 1 to infinity as $r_0$ ranges from one to infinity, so we need to make use of $\pi_1 = 7$; we substitute $r_0 = 7+1/r_1$ to get
\begin{equation}
[y_2,\cdots] = \frac{8 + 1/r_1}{6 + 1/r_1} = \frac{8r_1 + 1}{6r_1 + 1} = 1 + \frac{2r_1}{6r_1 + 1}= 1 + \frac{1}{[y_3,\cdots]}\ .
\end{equation}
Thus $y_2=1$.  We also get $y_3 = 3$ from
\begin{equation}
[y_3,\cdots] =  \frac{6r_1 + 1}{2r_1} = 3 + \frac{1}{2r_1} = 3 + \frac{1}{[y_4,\cdots]}\ .
\end{equation}

Going further will require substituting $r_1 = 15+1/r_2$ into $2r_1 = [y_4,\cdots]$.
It is now clear that we will generate terms of $y$ by repeatedly determining the integer part (i.e. floor) of expressions of the form
\begin{equation}\label{eq:homographic}
\frac{px+q}{rx+s}
\end{equation}
where $x>1$ and the continued fraction expansion of $x$ is known. Functions of this form are called \emph{homographic}.
We will identify a homographic function with the matrix
$\left(
\begin{smallmatrix} 
p & q\\ 
r & s 
\end{smallmatrix}
\right)$.

To formalize our observations, we first define the \emph{range} of the function given by (\ref{eq:homographic}) as the set of possible floors, i.e.
\begin{equation}
\mathcal{R}\pqrs = \left\{ \left\lfloor \frac{px+q}{rx+s} \right\rfloor | \  1 < x < \infty \right\}
\end{equation}
We will be able to produce the next term of output when this set is a singleton. If $-s/r \leq 1$ then the denominator cannot be zero, and the upper and lower limits are the min and max of $\{p/r, (p+q)/(r+s)\}$: if $p/r$ is the max, and is also an integer, then the integer part cannot be larger than $p/r-1$, since we are approaching $p/r$ from below. If  $-s/r > 1$ the range will be infinite, so there is no need to compute it explicitly; we need to transform the expression by incorporating more information about $x$.

We define two transformations on homographics. When the range of the homographic expression for $[y_j,y_{j+1},\cdots]$ is not a singleton set, we do not yet have enough information to determine $y_j$, and must $\emph{ingest}$ the next term of $x$. If this term is $k$ we make the substitution $x \leftarrow k + 1/x$, leading to the definition
\begin{equation}
\mbox{ingest}(k,\pqrs) = \homographic{kp+q}{p}{kr+s}{r}%\frac{(kp+q)x + p}{ (kr+s)x + r}
\end{equation}


When the range of the homographic expression for $[y_j,y_{j+1},\cdots]$ consists of a single integer $k$, we can \emph{produce}  the next output term $y_j = k$; the rest of the output, $[y_{j+1},y_{j+2},\cdots]$, is the continued fraction expansion of
\[
\frac{1}{\frac{px+q}{rx+s}-k} = \frac{rx+s}{(p-kr)x + (q-ks)}
\] 
so we define 
\begin{equation}
\mbox{produce}(k,\pqrs) = \homographic{r}{s}{p-kr}{q-ks}\ .
\end{equation}

Note that if we started with rational $x$, we will eventually reach $x_i = \infty$; ingesting infinity returns the limit ${\left(
\begin{smallmatrix} 
0 & p\\ 
0 & r
\end{smallmatrix}
\right)}$. This is the constant function at the rational number $p/q$, so there will never be any need to ingest the (nonexistent) subsequent 
terms of $x$. If we proceed as in the examples above, we will compute the CF representation of $p/q$ as the last part of the finite expansion of $y$, ending with a production that subtracts the final term $y_k$ from the expression $\frac{y_k}{1}$; this leads to $M=\left(\begin{smallmatrix}0 & 1 \\ 0 & 0\end{smallmatrix}\right)$, which we may read as infinity.

\begin{figure}
\begin{algorithmic}\label{fig:oneCFarith}
\STATE{$i \gets 0$} \COMMENT{index of the next term of $x$ we will read}
\STATE{$j \gets 0$} \COMMENT{index of the next term of $y$ we will generate}
\STATE{$M \gets \pqrs$} \COMMENT{the initial matrix, i.e. the expression whose CF we will compute}
\STATE{$M \gets \mbox{ingest}(x_0, M)$}
\STATE{$i \gets 1$}
\WHILE {$M \neq \infty$} 
	\WHILE{$\mathcal{R}(M)$ is not a singleton}
                   \STATE{$M \gets \mbox{ingest}(x_i, M)$}
                   \STATE{$i \gets i+1$}
           \ENDWHILE
           \STATE{$y_j \gets \mathcal{R}(M)$}
          \STATE{$M \gets \mbox{produce}(y_j,M)$}
          \STATE{$j \gets j+1$}
\ENDWHILE
\end{algorithmic}
\caption{Algorithm for arithmetic on a CF and a rational number}
\end{figure}

So now we have an algorithm for producing the CF expansion $[y_0,y_1,\cdots]$ of $\frac{px+q}{rx+s}$, assuming the expansion of $x$ is known. To compute $x/k$ we would start with $M=\left(
\begin{smallmatrix} 
1 & 0\\ 
0 & k 
\end{smallmatrix}
\right)$; 
to get $kx$ we would start with $M=\left(
\begin{smallmatrix} 
k & 0\\ 
0 & 1 
\end{smallmatrix}
\right)$; while $x+\frac{j}{k}$ would be $M=\left(
\begin{smallmatrix} 
k & j\\ 
0 & k 
\end{smallmatrix}
\right)$.



\subsection{Properties of the Algorithm}
The outer loop ``while $M \neq \infty$" is an infinite loop if $\mathbf{x} = [\mathbf{x}_0, \mathbf{x}_1,\cdots]$ is irrational (here we use boldface $\mathbf{x}$ for the real-valued input, as distinct from the symbolic variable $x$ in the homomorphic expression). This can be implemented quite directly in a language like Haskell\footnote{\href{https://haskell.org}{haskell.org}} with lazy evaluation; such languages support conceptually infinite data structures, which are a perfect fit for working with continued fractions. Under lazy evaluation, defining a variable $y$ to be the result of an algorithm just associates $y$ with the finite recursive expression that defines the algorithm; the number of $y$ terms actually generated will be only what is needed by subsequent computations.

The inner loop ``while $\mathcal{R}(M)$ is not a singleton" \emph{is} guaranteed to terminate; we will never be in an infinite loop waiting for the next term. We have already observed that this loop terminates if $\mathbf{x}$ is rational, so assume it is irrational. As we iterate through this loop, we are repeatedly rewriting the initial $M = \pqrs$
with $[\mathbf{x}_0, \cdots \mathbf{x}_i, x]$ in place of $x$. As $i$ goes to infinity, the upper and lower bounds on $[\mathbf{x}_0, \cdots \mathbf{x}_i, x]$ approach $\mathbf{x}$, so the upper and lower bounds of the matrix approach $\frac{p\mathbf{x}+q}{r\mathbf{x}+s}$. This limit is irrational, so eventually the bounding interval contains no integers; at this point $\mathcal{R}(M)$  will be a singleton (namely the common floor of all numbers in the interval), and we will produce a term.


\subsection{Visualizing the Algorithm}
Since $\mbox{ingest}(k,\pqrs)$ returns a matrix whose right column is
$\left( \begin{smallmatrix} p \\  r \end{smallmatrix}\right)$,
and $\mbox{produce}(k,\pqrs)$ returns a matrix whose top row is $(r\ s)$, we can visualize the progress of the algorithm as moving a $2 \times 2$ window through a two-dimensional grid of integers.
We start with $M$ in the upper right corner; \emph{ingest} moves left and \emph{produce} moves down. We put the $x_i$ on the top row,
at the positions where we ingest, and $y_j$ in the right column, at the positions where we produce. Here is such a representation
of our earlier example of $\pi/2$, taken further to use $\pi = [3,7,15, 1\cdots]$ to obtain $\pi/2 = [1,1,1,3,31,\cdots]$.

\begin{equation}\label{eq:2dgrid}
\begin{matrix}
 & & & 1& 15&       7&  3& &\\
 & & &  &        &     3&   1& 0&\\
 & & &  &        &     2&    0& 2& 1\\
 & & &  &        8&   1&    1&   &  1\\
 & & &  &        6&   1&    -1&  & 1\\
 & & 32& 30&  2& 0&        &  &  3\\
 & &  1&   1&  0&  1&        &  & 31\\
 & &   1&  -1&   &    &        &  &
\end{matrix}
\end{equation}


\section{Arithmetic on Two Continued Fractions}
We now turn to adding or multiplying two CFs. Conceptually, this is hardly any different from what we have already done; but it will raise some implementation issues that require care. As a motivating example, let
\[
z = \pi + \sqrt{2} = 4.555806215962888\cdots
\]
 with $[y_0, y_1,\cdots] = \sqrt{2} = [1,(2)]$. We can write this sum as
\begin{equation}
3 + \frac{1}{[\pi_1,\pi_2\cdots]} + 1 + \frac{1}{[y_1,\cdots]} = \frac{ 4[\pi_1,\cdots][y_1,\cdots] + [\pi_1,\cdots]  + [y_1\cdots]}{ [\pi_1,\cdots][y_1\cdots] }\ .
\end{equation}
Substituting $[\pi_1,\cdots] = 7 + 1/[\pi_2,\cdots]$ and $[y_1,\cdots] = 2 + 1/[y_2,\cdots]$ leads (after a lot of high-school algebra) to 
\begin{equation}
z = \frac{65[\pi_2,\cdots] [y_2,\cdots] + 29[\pi_2,\cdots] +9[y_2,\cdots] +4}{14[\pi_2,\cdots] [y_2,\cdots] + 7[\pi_2,\cdots] +2[y_2,\cdots] +1}
\end{equation}
The integer parts of $\frac{65}{14}, \frac{29}{7}, \frac{9}{2}$ and  $\frac{4}{1}$ are all 4; therefore $\lfloor z \rfloor =4$. The next term will be the floor of
\begin{equation}
\frac{1}{z-4} =  \frac{14[\pi_2,\cdots] [y_2,\cdots] + 7[\pi_2,\cdots] +2[y_2,\cdots] +1}{9[\pi_2,\cdots] [y_2,\cdots] + [\pi_2,\cdots] +[y_2,\cdots]}
\end{equation}
into which we can substitute  $[\pi_2,\cdots]=15+\frac{1}{[\pi_3,\cdots]},  [y_2,\cdots]=2+\frac{1}{[y_3,\cdots]}$ and so on.

Similarly, the product $\pi\sqrt{2}=4.442882938158366\cdots$ is
\begin{equation}\label{eq:cfMult}
(3 + \frac{1}{[\pi_1,\cdots]})(1 + \frac{1}{[y_1\cdots]}) 
  = \frac{ 3[\pi_1,\cdots][y_1\cdots] + 3[\pi_1,\cdots] + [y_1\cdots] +1 }{[\pi_1,\cdots][y_1\cdots] }\ .
\end{equation}
into which we can make the same substitutions. 

In general, computing terms of a sum or product of CFs will require finding the floors of two-variable expressions of the form
\begin{equation}\label{eq:bihomographic}
\frac{axy + bx + cy + d}{exy + fx + gy + h}
\end{equation}
where $x$ and $y$ independently vary from 1 to $\infty$. Such an expression is called \emph{bihomographic}, and will be represented by the matrix $\abcd$. To determine bounds on the floor of (\ref{eq:bihomographic}), it is convenient to make the substitutions $\hat{x} = x-1, \hat{y} = y-1$, and consider
\[
\frac{a\hat{x}\hat{y} + (a+b)\hat{x} + (a+c)\hat{y} + (a+b+c+d)}{e\hat{x}\hat{y} + (e+f)\hat{x} + (e+g)\hat{y} + (e+f+g+h)}
\]
as $\hat{x}, \hat{y}$ range independently from \emph{zero} to infinity. If the denominator cannot be zero, the floor is always between the minimum and maximum of
\[
\left\{ \frac{a}{e},\frac{a+b}{e+f},\frac{a+c}{e+g},\frac{a+b+c+d}{e+f+g+h} \right\}\ .
\]

When the floor (i.e. the next term of output) is known, we produce output $z_j=k$ and the next bihomographic expression is
\[
\left(\frac{axy + bx + cy + d}{exy + fx + gy + h} - k\right)^{-1} = \frac{exy + fx + gy + h}{(a-ke)xy + (b-kf)x + (c-kg)y + (d-kh)}
\]
so we define the corresponding operation on matrices
\[
\mbox{produce}(k, \abcd) = \bihomographic{e}{f}{g}{h}{(a-ke)}{(b-kf)}{(c-kg)}{(d-kh)}
\]
 If the floor is not determined, we must narrow its range by ingesting the next term of either $x$ or $y$. If we use $y = [s,y_{k+1},y_{k+2}\cdots]$, we make the substitution $y \leftarrow s + 1/y$ to get
\[
\frac{(sa+b)xy + ax + (sc+d)y + c}{(se+f)xy + ex + (sg+h)y + g}
\]
so we define
\[
\mbox{ingest\_y}(s, \abcd) = \bihomographic{(sa+b)}{a}{(sc+d)}{c}{(se+f)}{e}{(sg+h)}{g}
\]
with the analogous 
\[\
\mbox{ingest\_x}(s, \abcd) = \bihomographic{(sa+c)}{(sb+d)}{a}{b} {(ae+g)}{(af+h)}{e}{f}
\] 
for the result of substituting $x \leftarrow s + 1/x$.


\begin{figure}
\begin{algorithmic}\label{fig:twoCFarithPrelim}
\STATE{$i \gets 0$} \COMMENT{index of the next term of $x$ and $y$ we will read}
\STATE{$j \gets 0$} \COMMENT{index of the next term of $z$ we will generate}
\STATE{$M \gets \abcd$} \COMMENT{the initial matrix, i.e. the expression whose CF we will compute}
\STATE{$M \gets \mbox{ingest\_y}(y_0, \mbox{ingest\_x}(x_0, M))$}
\STATE{$i \gets 1$}
\WHILE {$M \neq \infty$} 
	\WHILE{$\mathcal{R}(M)$ is not a singleton}
                   \STATE{$M \gets \mbox{ingest\_y}(y_i, \mbox{ingest\_x}(x_i, M))$}
                   \STATE{$i \gets i+1$}
           \ENDWHILE
           \STATE{$z_j \gets \mathcal{R}(M)$}
          \STATE{$M \gets \mbox{produce}(z_j,M)$}
          \STATE{$j \gets j+1$}
\ENDWHILE
\end{algorithmic}
\caption{Preliminary algorithm for arithmetic on two CFs.}
\end{figure}

We now have a preliminary algorithm for arithmetic; this will in fact require substantial modification, but we include it as a summary of the key ideas. It is not much different from the single-CF case. Computation of $x+y, x-y,xy$, and $x/y$ begin with matrices $\bihomographic{0}{1}{1}{0}{0}{0}{0}{1}, \bihomographic{0}{1}{-1}{0}{0}{0}{0}{1}, \bihomographic{1}{0}{0}{0}{0}{0}{0}{1}$ and $\bihomographic{0}{1}{0}{0}{0}{0}{1}{0}$.

Note that it is not at all necessary to ingest terms of both inputs in lockstep as we have here;
Gosper suggests heuristics for accelerating the algorithm by choosing the input term most likely to get us to the next production step more quickly. This appears to be a worthwhile subject for further work.

It is interesting that the algorithms for all arithmetic operations are identical, except for the initial $M$. The reason, one might say, is that division is the hardest arithmetic operation, and the definition of continued fractions has division built-in to everything.


\subsection{Failure to Converge}
Algorithm (\ref{fig:twoCFarithPrelim}) demonstrates the basic idea of CF arithmetic, but is insufficient because it can fail to converge; we might endlessly ingest terms of both $x$ and $y$ without ever obtaining a bihomographic expression whose floor is known. The simplest case is multiplying $\sqrt{2}$ by itself. The first iteration, ingesting 1 from $x$ and from $y$, gives
\begin{equation}\label{eq:bound1}
z = \sqrt{2}*\sqrt{2} = [z_0,z_1, \cdots] = \bihom{1}{1}{1}{1}{1}{0}{0}{0} \ .
\end{equation}
Repeatedly ingesting 2 from both $x$ and $y$ yields
\begin{equation}\label{eq:bound2}
[z_0,z_1, \cdots]  =  \bihom{9}{3}{3}{1}{4}{2}{2}{1}
\end{equation}
\begin{equation}\label{eq:bound3}
[z_0,z_1, \cdots]  =  \bihom{49}{21}{21}{9}{25}{20}{10}{4}
\end{equation}
\begin{equation}\label{eq:bound4}
[z_0,z_1, \cdots]  =  \bihom{289}{119}{119}{49}{144}{60}{60}{25}
\end{equation}
and so on. The matrix (\ref{eq:bound2}) takes values ranging from $\frac{16}{9}$ to $\frac{9}{4}$ (i.e. 1.777 to 2.25) as $x$ and $y$ range from one to infinity;
similarly matrix (\ref{eq:bound3}) is between $\frac{49}{25}$ and $\frac{100}{49}$ (i.e. 1.96 to 2.0408). And the last ranges from $\frac{576}{289}$ to $\frac{289}{144}$, which is about 1.993 to 2.00694.

The source of the problem is now clear: we should have $z=[z_0,z_1]=[2,\infty]$, but no finite number of terms can ever tell us that $z_0=2$. It is always possible that one input is in fact less than $\sqrt{2}$, so it is always possible that $z<2$ and $z_0=1$.

Our approach to the problem is to separate the internal representation of a CF as a data structure from the mathematical notion of a  sequence of integer terms. The internal representation will contain explicit terms (i.e. $z_k=n$) whenever such can be determined, but might also contain arbitrary bounds on the tail $[z_k, z_{k+1}\cdots]$, such as the  sequence of bounds we derived for $\sqrt{2}*\sqrt{2}$. This is a direct generalization, because the explicit term  $z_k=n$ is equivalent to the bound 
\[
n \leq [z_k, z_{k+1}\cdots] < n+1 \ .
\]
Therefore, when a CF is constructed explicitly from a known sequence of terms $[z_0, z_1, \cdots]$, it will be represented internally as the sequence of half-open intervals
\[
[[z_0, z_0+1),  [z_1, z_1+1), \cdots]\ .
\] 
At the opposite extreme, the internal representation for $\sqrt{2}^2$ will consist entirely of ever-tighter bounds on the first term, i.e. the sequence of intervals
\[
[[\frac{16}{9},\frac{9}{4}), [\frac{49}{25},\frac{100}{49}), [\frac{576}{289},\frac{289}{144}), \cdots]\ .
\] 

The general idea (elaborated more fully in section \label{sec:finalAlgorithm}) is that we will generate output on \emph{every} iteration of the arithmetic algorithm; when we cannot produce a term, we output upper and lower bounds on the current homomorphic matrix, leaving the matrix unchanged. Reading such output, there can be no ambiguity about the term to which a bound applies; the first bound applies to $z_0$, and as soon as we encounter a bound which uniquely determines $z_k$ (i.e. an interval with $\lfloor x \rfloor$ the same for all $x$ in the interval), we know that the next bound will apply to $z_{k+1}$. This implies that any finite prefix of the output sequence will determine a finite prefix $[z_0 \cdots z_{k-1}]$ of the actual CF, followed by a bound $[\ell_k,u_k)$ on the tail $[z_k, z_{k+1}\cdots]$. The exact value of the CF is between $[z_0 \cdots z_{k-1}, \ell_k]$ and $[z_0 \cdots z_{k-1}, u_k]$ (where we extend the usual CF notation by allowing a rational number, instead of an integer, as the last term).

Note that storage of a long sequence of intervals is not a problem for implementation; successive bounds on the same term are always tighter, so there is no need to retain earlier bounds when a new one is obtained. 

\subsection{Extracting Terms}
We must note that our representation of CF arithmetic makes it \emph{impossible} to simply ask a question like ``what are the first five terms of $z = xy$?" An explicit list of terms can only be relative to a required degree of accuracy $\varepsilon$. Our arithmetic algorithms consume and return theoretically infinite sequences of intervals; extracting a sequence of terms is a separate ``post-processing" step. To obtain terms, we find a prefix of the output interval sequence which is long enough to make the difference between $[z_0 \cdots z_{k-1}, \ell_k]$ and $[z_0 \cdots z_{k-1}, u_k]$ less than $\varepsilon$; then our approximate CF is $[z_0 \cdots z_k]$, where $z_k$ is some integer in the interval $[\ell_k,u_k)$. By convention we may take $z_k = \lfloor u_k \rfloor$. 

In the case of $\sqrt{2}^2$, any accuracy threshold will yield the same result, $z = [2,\infty]$.


\subsection{An Algorithm for CF Arithmetic}\label{sec:finalAlgorithm}
We now present the full details of the algorithm suggested in the previous section.  We augment the matrix $M$ with a pair of intervals $\{I_x, I_y\} = \{[x_{\ell},x_{u}), [y_{\ell}, y_{u})\}$, the current bounds on the remaining tails of the inputs $x,y$. These intervals start at $(-\infty, \infty)$, since the first term could be any integer. When we ingest an interval of the form $[a,a+1)$ from $x$ or from $y$, we modify $M$ as before with $M \leftarrow \mbox{ingest\_x}(a,M)$ or $M \leftarrow \mbox{ingest\_y}(a,M)$, and we change that variable's bound to $[1, \infty)$. When we ingest an \emph{ambiguous} interval $[\ell, u)$ (i.e. a bound that does not determine the next term of the input), we replace the current bound on the corresponding variable with $[\ell, u)$, leaving $M$ unchanged. 

We define $\mathcal{R}(M)$ to take the bounds into account, i.e.
\begin{equation}
\mathcal{R}\left(\abcd, I_x, I_y\right) = \left\{ \left\lfloor \bihom{a}{b}{c}{d}{e}{f}{g}{h} \right\rfloor | \  x \in I_x, y \in I_y \right\}
\end{equation}
When this is a singleton set $\{n\}$, we output $[n,n+1)$ and modify $M$ as before with $M \leftarrow \mbox{produce}(n,M)$; the bounds $I_x$ and $I_y$ do not change. Otherwise we leave $M$ unchanged and output upper and lower bounds on $M$, i.e. the min and max of $\bihom{a}{b}{c}{d}{e}{f}{g}{h}$ subject to $x \in I_x, y \in I_y$; denote this interval $\rho\left(\abcd, I_x, I_y\right)$. These bounds are easily computed, see section (\ref{sec:ComputeBounds}). To retain unlimited accuracy, the bounds must be computed with exact rational arithmetic.



\begin{figure}
\begin{algorithmic}\label{fig:twoCFarith}
\STATE{}\COMMENT{input $x,y$: CFs represented as lists of intervals}
\STATE{}\COMMENT{input $M$: bihomomorphic matrix}
\STATE{}\COMMENT{output $z$: CF expansion of $M(x,y)$ represented as list of intervals}
\STATE{$i \gets 0$} \COMMENT{index of the next element of $x$ and $y$ we will read}
\STATE{$j \gets 0$} \COMMENT{index of the next element of $z$ we will generate}
\STATE{$I_x,I_y \gets (-\infty, \infty),(-\infty, \infty)$} \COMMENT{current bounds on remaining parts of $x,y$}
\WHILE {$M \neq \infty$}
    \STATE{}\COMMENT{read input}
     \IF{$x_i$ is ambiguous}
         \STATE{$I_x \gets x_i$}
     \ELSE
         \STATE{$M \gets \mbox{ingest\_x}( x_i, M)$}
         \STATE{$I_x \gets [1,\infty)$}
     \ENDIF
     \IF{$y_i$ is ambiguous}
         \STATE{$I_y \gets y_i$}
     \ELSE
         \STATE{$M \gets \mbox{ingest\_y}( y_i, M)$}
         \STATE{$I_y \gets [1,\infty)$}
     \ENDIF
     \STATE{$i \gets i+1$}
     
     \STATE{}\COMMENT{produce output}
     \IF{$\mathcal{R}(M,I_x,I_y)$ is not a singleton}
        \STATE{$z_j \gets \rho(M,I_x, I_y)$}
     \ELSE
         \STATE{$z_j \gets \mathcal{R}(M,I_x,I_y)$}
         \STATE{$M \gets \mbox{produce}(z_i, M)$}
     \ENDIF
     \STATE{$j \gets j+1$}
\ENDWHILE
\end{algorithmic}
\caption{Algorithm for arithmetic on two CFs.}
\end{figure}


\subsection{Possible Optimizations of the CF Arithmetic Algorithm}
\subsubsection{Winnowing Interval Sequences}
When we have to ingest the next interval from $x$ or $y$, and we see an ambiguous interval at the head of the list, it is not necessary to ingest that interval; we may skip it and go on to the next element of the list, which will give a tighter bound on the next term. Any such heuristic must guarantee that, given an infinite list of ambiguous input intervals, we eventually ingest something. Similarly, the algorithm does not need to output every ambiguous interval of $z$; but  we must guarantee that we eventually output something, even if we are generating an infinite list of ambiguous intervals.

\subsubsection{Taming Large Coefficients}
If a high degree of accuracy is required, the coefficients of $M$ may grow very large; performing rational arithmetic on arbitrarily large integers will incur a performance penalty. We might be able to take advantage of the fact that we do not require the tightest possible bounds on the next term; the only requirement for correctness is that the bounds converge to the correct value. We might divide every coefficient of $M$ by some large integer $k$, rounding each result up or down in whichever direction slightly widens the range of $M$. We might do the same with intervals whose numerators and denominators are very large. To guarantee convergence, we must never make an adjustment which makes a new bound weaker than the current bound.

Any such decision to ``simplify" $M$ must consider the gap between the upper and lower bounds of $M$; if the gap is large relative to the reciprocals of the coefficients, we might be carrying too many digits. Remember that, with lazy evaluation, all computations are driven by how much accuracy we need; If the gap is small, yet we are still continuing the computation, it means that we need even tighter bounds. In such cases large coefficients might be unavoidable.


\subsection{Computing the range of $M$}\label{sec:ComputeBounds}
To compute min and max of $M$ subject to $x_{\ell} < x < x_u, y_{\ell} < y < y_u$:
\begin{itemize}
\item Let $\delta_x, \delta_y = x_u - x_{\ell}, y_u - y_{\ell}$
\item Substitute $x \leftarrow x_{\ell} + \frac{\delta}{x'+1}$ and $y \leftarrow y_{\ell} + \frac{\delta}{y'+1}$. Now $x$ goes from $x_{\ell}$ to $x_u$ as $x'$ goes from 0 to infinity, similarly for $y,y'$
\item Let the coefficients of the resulting matrix be $\bihomographic{a'}{b'}{c'}{d'}{e'}{f'}{g'}{h'}$
\end{itemize}
The range of $M$ subject to the bounds will be the min and max of 
\[
\left\{ \frac{a'}{e'},\frac{b'}{f'},\frac{c'}{g'},\frac{d'}{h'} \right\}\ .
\]

\end{document}  