\documentclass[11pt, oneside]{amsart}   	% use "amsart" instead of "article" for AMSLaTeX format
\usepackage{geometry}                		% See geometry.pdf to learn the layout options. There are lots.
\geometry{letterpaper}                   		% ... or a4paper or a5paper or ... 
%\geometry{landscape}                		% Activate for rotated page geometry
%\usepackage[parfill]{parskip}    		% Activate to begin paragraphs with an empty line rather than an indent
\usepackage{graphicx}				% Use pdf, png, jpg, or epsÂ§ with pdflatex; use eps in DVI mode
								% TeX will automatically convert eps --> pdf in pdflatex		
\usepackage{amssymb}
\usepackage{algorithmic}
\usepackage{hyperref}
%SetFonts
\newcommand{\pqrs}{\left(
\begin{smallmatrix} 
p & q\\ 
r & s 
\end{smallmatrix}
\right)}

\newcommand{\homographic}[4]{\begin{pmatrix} #1 & #2\\ #3 & #4 \end{pmatrix}}
\newcommand{\bihomographic}[8]{\left(\begin{smallmatrix}#1&#2&#3&#4\\#5&#6&#7&#8\end{smallmatrix}\right)}
\newcommand{\bihom}[8]{{\frac{#1 xy + #2 x + #3 y + #4}{#5 xy + #6 x + #7 y + #8}}}

\newcommand{\abcd}{\left(
\begin{smallmatrix} 
a & b & c & d\\ 
e & f & g & h
\end{smallmatrix}
\right)}

\renewcommand{\:}{\negthickspace:\negthickspace}

\title{Arithmetic on Continued Fractions}
\author{Michael J. Collins\\Associate Research Scientist\\Daniel H. Wagner Associates\\Hampton, VA USA\\mjcollins10@gmail.com}
%\date{} % Activate to display a given date or no date

\begin{document}

\begin{abstract}
Gosper  developed algorithms for adding, subtracting, multiplying, or dividing two continued fractions (CFs), and for solving quadratics with CF coefficients,
getting a CF as the result. Straightforward implementation of these algorithms leads to infinite loops; here we present a modified version of Gosper's arithmetic algorithm and prove that it avoids all difficulties with infinite loops. We then extend the arithmetic algorithm in a natural way to compute exponential, log, and trig functions on CFs.
We have implemented these algorithms in Haskell.
\end{abstract}

\maketitle

\section{Introduction}
A simple continued fraction\footnote{\href{https://en.wikipedia.org/wiki/Simple\_continued\_fraction}{https://en.wikipedia.org/wiki/Simple\_continued\_fraction}} is a (possibly infinite) expression of the form
\begin{equation*}
a_0+\cfrac{1}{a_1+\cfrac{1}{a_2+\cfrac{1}{a_3+\cdots}}}
\end{equation*}
where the terms $a_i$ are integers. It can be written more compactly as $[a_0, a_1, \cdots]$\footnote{Many authors write this as $[a_0; a_1, \cdots]$}. Here we consider only \emph{regular} simple continued fractions, which means $a_i \geq 1$ when $i>0$. The
properties of continued fractions, and the motivations for studying them, are very well-known \cite{rockett1992continued},
so here we only remind the reader of some notation we will use:
\begin{itemize}
\item A quadratic irrational has a periodic CF expansion. We denote the periodic part by putting it in parentheses,
i.e $[1,(2,3)] = [1,2,3,2,3,2,3,\cdots]$.
\item A rational number has a finite CF expansion $[a_0,a_1, \cdots a_k]$.
It will be convenient to consider a finite CF as ending with an infinite term $a_{k+1}=\infty$, treating $\frac{1}{\infty}$ as equal to zero.
\end{itemize}
 
Gosper (in an appendix to the famous HAKMEM report \cite{hakmem}) 
developed algorithms for performing arithmetic on two CFs, and for solving quadratics with CF coefficients, getting a CF as the result;
the point of course is that we can do this entirely within the CF representation, making no use of floating-point operations. Here we
present modified versions of those algorithms and prove that these modifications avoid all difficulties with infinite loops;
any combination of arithmetic operations can be carried out to any required degree of accuracy in a finite number of steps.

We then extend the arithmetic algorithm to compute CF representations of $e^x, \log(x)$, and trigonometric functions of $x$, where $x$ is given as a CF. 
Of course, since we can do arithmetic, we can compute any $n^{th}$ degree Taylor polynomial approximation of such functions to any degree of accuracy.
We go further, developing an iterative algorithm which continually generates terms of the CF, always using precisely as much of the series (and as many terms of $x$) as is required to determine the next output term.

We have implemented these algorithms
in Haskell\footnote{\href{https://github.com/mjcollins10/ContinuedFractions}{https://github.com/mjcollins10/ContinuedFractions}}.


\section{Arithmetic on One CF}
Before we describe how to add or multiply two CFs, we consider the simpler problem of operations combining a single CF with a
rational number $p/q$. A few examples reveal there is no evident general pattern for transforming the CF terms of irrational $x$ into
the terms of $px/q$ or $x + p/q$, even in the apparently simplest cases:
\begin{eqnarray*}
\sqrt{7} & = & [2, (1, 1, 1, 4)] \\
\sqrt{7}/2 & = & [1, (3, 10, 3, 2)] \\
\sqrt{11} & = & [3, (3, 6)] \\
\sqrt{11}/2 & = & [1, (1, 1, 1, 12, 1, 1, 1, 2)] \\
\pi & = & [3,7,15,1,292,1,1,1, 2, 1, 3,\cdots]\\
\pi + 1/2 & = & [3, 1, 1, 1, 3, 1, 3, 4, 73, 6, 3, 3, 2, 1, 3\cdots]
\end{eqnarray*}
As a motivating example for the general algorithm, we compute
\[[y_0,y_1,y_2 \cdots] = \pi/2 = 1.5707963267948966\cdots\ .
\]
Let $\pi = [\pi_0,\pi_1,\cdots]$ (in general we use $x_i$ for the $i^{\mbox {th}}$ CF term of a real number $x$). It will be convenient to have notation for the ``tail" of a continued fraction, so let
\[
r_i = [\pi_{i+1}, \pi_{i+2},\cdots]\ .
\]
Note that all $r_i \geq 1$, and $r_i = \pi_{i+1} + 1/r_{i+1}$. The fact that $\pi_0 = \lfloor \pi \rfloor= 3$
is enough to determine $y_0=\lfloor \pi/2 \rfloor=1$; more precisely
\begin{equation*}
y = \frac{\pi}{2} = \frac{3 + 1/r_0}{2} = \frac{3r_0+1}{2r_0} = 1 + \frac{r_0+1}{2r_0}= 1 + \frac{1}{[y_1,y_2,\cdots]}\ .
\end{equation*}
Now we have to get $y_1$ from 
\begin{equation*}
[y_1,y_2,\cdots] = \frac{2r_0}{r_0+1}\ .
\end{equation*}
The mere fact that $r_0>1$ is enough to tell us that $\lfloor \frac{2r_0}{r_0+1} \rfloor = 1$, so we obtain $y_1=1$ and continue
\begin{equation*}
[y_1,y_2,\cdots] = 1 + \frac{r_0-1}{r_0+1} = y_1 + \frac{1}{[y_2,y_3\cdots]}
\end{equation*}
\begin{equation*}
[y_2,\cdots] = \frac{r_0+1}{r_0-1} \ .
\end{equation*}
Now the floor of $\frac{r_0+1}{r_0-1}$ ranges from one to infinity as $r_0$ ranges from one to infinity,
so we need to make use of $\pi_1 = 7$; we substitute $r_0 = 7+1/r_1$ to get
\begin{equation*}
[y_2,\cdots] = \frac{8 + 1/r_1}{6 + 1/r_1} = \frac{8r_1 + 1}{6r_1 + 1} = 1 + \frac{2r_1}{6r_1 + 1}= 1 + \frac{1}{[y_3,\cdots]}\ .
\end{equation*}
Thus $y_2=1$.  We also get $y_3 = 3$ from
\begin{equation*}
[y_3,\cdots] =  \frac{6r_1 + 1}{2r_1} = 3 + \frac{1}{2r_1} = 3 + \frac{1}{[y_4,\cdots]}\ .
\end{equation*}

Going further will require substituting $r_1 = 15+1/r_2$ into $2r_1 = [y_4,\cdots]$.
It is now clear that we will generate terms of $y$ by repeatedly determining the integer part (i.e. floor) of expressions of the form
\begin{equation}\label{eq:homographic}
\frac{px+q}{rx+s}
\end{equation}
where $x>1$ and the continued fraction expansion of $x$ is known. Functions of this form are called \emph{homographic}.
We will identify a homographic function with the matrix
$\left(
\begin{smallmatrix} 
p & q\\ 
r & s 
\end{smallmatrix}
\right)$.

To formalize our observations, we first define the \emph{range} of the function given by (\ref{eq:homographic})
as the set of possible floors, i.e.
\[
\mathcal{R}\pqrs = \left\{ \left\lfloor \frac{px+q}{rx+s} \right\rfloor | \  1 \leq x < \infty \right\}
\]
We will be able to produce the next term of output when this set is a singleton. If $-s/r \leq 1$ then the denominator cannot be zero,
and the upper and lower limits are the min and max of $\{p/r, (p+q)/(r+s)\}$: if $p/r$ is the max, and is also an integer, then the
integer part cannot be larger than $p/r-1$, since we are approaching $p/r$ from below. If  $-s/r > 1$ the range will be infinite, so
there is no need to compute it explicitly; we need to transform the expression by incorporating more information about $x$.

We define two transformations on homographics. When the range of the homographic expression for $[y_j,y_{j+1},\cdots]$ is not a
singleton set, we do not yet have enough information to determine $y_j$, and must $\emph{ingest}$ the next term of $x$. If this term
is $k$ we make the substitution $x \leftarrow k + 1/x$, leading to the definition
\[
\mbox{ingest}(k,\pqrs) = \homographic{q+kp}{p}{s+kr}{r}%\frac{(kp+q)x + p}{ (kr+s)x + r}
\]

When the range of the homographic expression for $[y_j,y_{j+1},\cdots]$ consists of a single integer $k$, we can \emph{produce}
the next output term $y_j = k$; the rest of the output, $[y_{j+1},y_{j+2},\cdots]$, is the continued fraction expansion of
\[
\frac{1}{\frac{px+q}{rx+s}-k} = \frac{rx+s}{(p-kr)x + (q-ks)}
\] 
so we define 
\[
\mbox{produce}(k,\pqrs) = \homographic{r}{s}{p-kr}{q-ks}\ .
\]

If we started with rational $x$, we will eventually reach $x_i = \infty$; ingesting infinity returns the limit ${\left(
\begin{smallmatrix} 
0 & p\\ 
0 & r
\end{smallmatrix}
\right)}$.
This is the constant function at the rational number $p/q$, so there will never be any need to ingest the (nonexistent) subsequent 
terms of $x$. If we proceed as in the examples above, we will compute the CF representation of $p/q$ as the last part of the finite
expansion of $y$, ending with a production that subtracts the final term $y_k$ from the expression $\frac{y_k}{1}$; this leads to
$M=\left(\begin{smallmatrix}0 & 1 \\ 0 & 0\end{smallmatrix}\right)$, which we may read as infinity.

\begin{figure}\label{fig:oneCFarith}
\begin{algorithmic}
\STATE{$i \gets 0$} \COMMENT{index of the next term of $x$ we will read}
\STATE{$j \gets 0$} \COMMENT{index of the next term of $y$ we will generate}
\STATE{$M \gets \pqrs$} \COMMENT{the initial matrix, i.e. the expression whose CF we will compute}
\STATE{$M \gets \mbox{ingest}(x_0, M)$}
\STATE{$i \gets 1$}
\WHILE {$M \neq \left(\begin{smallmatrix}0 & 1 \\ 0 & 0\end{smallmatrix}\right)$} 
	\WHILE{$\mathcal{R}(M)$ is not a singleton}
                   \STATE{$M \gets \mbox{ingest}(x_i, M)$}
                   \STATE{$i \gets i+1$}
           \ENDWHILE
           \STATE{$y_j \gets \mathcal{R}(M)$}
          \STATE{$M \gets \mbox{produce}(y_j,M)$}
          \STATE{$j \gets j+1$}
\ENDWHILE
\end{algorithmic}
\caption{Algorithm for arithmetic on a CF and a rational number}
\end{figure}

So now we have an algorithm for producing the CF expansion $[y_0,y_1,\cdots]$ of $\frac{px+q}{rx+s}$,
assuming the expansion of $x$ is known.
To compute $x/k$ we would start with $M=\left(
\begin{smallmatrix} 
1 & 0\\ 
0 & k 
\end{smallmatrix}
\right)$; 
to get $kx$ we would start with $M=\left(
\begin{smallmatrix} 
k & 0\\ 
0 & 1 
\end{smallmatrix}
\right)$; while $x+\frac{j}{k}$ would be $M=\left(
\begin{smallmatrix} 
k & j\\ 
0 & k 
\end{smallmatrix}
\right)$. Note that computing an arbitrary homomorphic expression $\pqrs$ is no more difficult than a single arithmetic operation.


\subsection{Proof of Termination}
The outer loop ``while $M \neq \infty$" is an infinite loop if $\mathbf{x} = [\mathbf{x}_0, \mathbf{x}_1,\cdots]$ is irrational
(here we use boldface $\mathbf{x}$ for the real-valued input, as distinct from the symbolic variable $x$ in the homographic
expression). This can be implemented quite directly in a language like Haskell\footnote{\href{https://haskell.org}{haskell.org}} with
lazy evaluation\cite{hutton2007programming}; such languages support conceptually infinite data structures, which are a perfect fit for working with continued
fractions. Under lazy evaluation, defining a list-type variable $y$ to be the result of an algorithm just associates $y$ with the finite recursive
expression that defines the algorithm; the number of elements of $y$ actually generated will be only what is needed by subsequent computations.

The inner loop ``while $\mathcal{R}(M)$ is not a singleton" \emph{is} guaranteed to terminate; we will never be in an infinite loop
waiting for the next term. We have already observed that this loop terminates if $\mathbf{x}$ is rational, so assume it is irrational. As
we iterate through the inner loop, we are repeatedly rewriting the initial $M = \pqrs$
with $[\mathbf{x}_0, \cdots \mathbf{x}_i, x]$ in place of $x$. As $i$ goes to infinity, the upper and lower bounds on
$[\mathbf{x}_0, \cdots \mathbf{x}_i, x]$ approach $\mathbf{x}$, so the upper and lower bounds of the matrix approach
$\frac{p\mathbf{x}+q}{r\mathbf{x}+s}$.
If this limit is irrational, eventually the bounding interval contains no integers; at this point $\mathcal{R}(M)$  will be a singleton
(namely the common floor of all numbers in the interval), and we will produce a term. The limit is rational only in the degenerate case
of
\[
\frac{p\mathbf{x}+q}{r\mathbf{x}+s} = \frac{na\mathbf{x}+nb}{da\mathbf{x}+db}
\]
but in that case we will immediately produce $\lfloor \frac{n}{d} \rfloor$ as the next term,
and the next iteration will have $M =\left(
\begin{smallmatrix} 
0 & j\\ 
0 & k 
\end{smallmatrix}
\right)$, where $\frac{j}{k} = 1/(\frac{n}{d}  -\lfloor \frac{n}{d} \rfloor)$, or $M = \left(\begin{smallmatrix}0 & 1 \\ 0 & 0\end{smallmatrix}\right)$ if $\frac{n}{d}$ is an integer.

\subsection{Visualizing the Algorithm}
Since $\mbox{ingest}(k,\pqrs)$ returns a matrix whose right column is
$\left( \begin{smallmatrix} p \\  r \end{smallmatrix}\right)$,
and $\mbox{produce}(k,\pqrs)$ returns a matrix whose top row is $(r\ s)$, we can visualize the progress of the algorithm
as moving a $2 \times 2$ window through a two-dimensional grid of integers.
We start with $M$ in the upper right corner; ingest moves left and produce moves down.
We put the $x_i$ on the top row, at the positions where we ingest, and $y_j$ in the right column, at the positions where we produce.
Here is such a representation of our earlier example of $\pi/2$, taken further to use $\pi = [3,7,15, 1\cdots]$ to obtain $\pi/2 = [1,1,1,3,31,\cdots]$.

\begin{equation*}\label{eq:2dgrid}
\begin{matrix}
 & & & 1& 15&       7&  3& &\\
 & & &  &        &     3&   1& 0&\\
 & & &  &        &     2&    0& 2& 1\\
 & & &  &        8&   1&    1&   &  1\\
 & & &  &        6&   1&    -1&  & 1\\
 & & 32& 30&  2& 0&        &  &  3\\
 & &  1&   1&  0&  1&        &  & 31\\
 & &   1&  -1&   &    &        &  &
\end{matrix}
\end{equation*}


\section{Arithmetic on Two Continued Fractions}
We now turn to adding or multiplying two CFs. Conceptually, this is hardly any different from what we have already done;
but it will raise some implementation issues that require care. As a motivating example, let
\[
z = \pi + \sqrt{2} = 4.555806215962888\cdots
\]
 with $[y_0, y_1,\cdots] = \sqrt{2} = [1,(2)]$. We can write this sum as
\begin{equation*}
3 + \frac{1}{[\pi_1,\pi_2\cdots]} + 1 + \frac{1}{[y_1,\cdots]} = \frac{ 4[\pi_1,\cdots][y_1,\cdots] + [\pi_1,\cdots]  + [y_1\cdots]}{ [\pi_1,\cdots][y_1\cdots] }\ .
\end{equation*}
Substituting $[\pi_1,\cdots] = 7 + 1/[\pi_2,\cdots]$ and $[y_1,\cdots] = 2 + 1/[y_2,\cdots]$ leads (after a lot of high-school algebra) to 
\begin{equation*}
z = \frac{65[\pi_2,\cdots] [y_2,\cdots] + 29[\pi_2,\cdots] +9[y_2,\cdots] +4}{14[\pi_2,\cdots] [y_2,\cdots] + 7[\pi_2,\cdots] +2[y_2,\cdots] +1}
\end{equation*}
The integer parts of $\frac{65}{14}, \frac{29}{7}, \frac{9}{2}$ and  $\frac{4}{1}$ are all 4; therefore $\lfloor z \rfloor =4$.
The next term will be the floor of
\begin{equation*}
\frac{1}{z-4} =  \frac{14[\pi_2,\cdots] [y_2,\cdots] + 7[\pi_2,\cdots] +2[y_2,\cdots] +1}{9[\pi_2,\cdots] [y_2,\cdots] + [\pi_2,\cdots] +[y_2,\cdots]}
\end{equation*}
into which we can substitute  $[\pi_2,\cdots]=15+\frac{1}{[\pi_3,\cdots]},  [y_2,\cdots]=2+\frac{1}{[y_3,\cdots]}$ and so on.

Similarly, the product $\pi\sqrt{2}=4.442882938158366\cdots$ is
\begin{equation*}
(3 + \frac{1}{[\pi_1,\cdots]})(1 + \frac{1}{[y_1\cdots]}) 
  = \frac{ 3[\pi_1,\cdots][y_1\cdots] + 3[\pi_1,\cdots] + [y_1\cdots] +1 }{[\pi_1,\cdots][y_1\cdots] }
\end{equation*}
into which we can make the same substitutions. 

In general, computing terms of a sum or product of CFs will require finding the floors of two-variable expressions of the form
\begin{equation}\label{eq:bihomographic}
\frac{axy + bx + cy + d}{exy + fx + gy + h}
\end{equation}
where $x$ and $y$ independently vary from 1 to $\infty$. Such an expression is called \emph{bihomographic}, and will be
represented by the matrix $\abcd$. To determine bounds on the floor of (\ref{eq:bihomographic}), it is convenient to make the
substitutions $\hat{x} = x-1, \hat{y} = y-1$, and consider
\[
\frac{a\hat{x}\hat{y} + (a+b)\hat{x} + (a+c)\hat{y} + (a+b+c+d)}{e\hat{x}\hat{y} + (e+f)\hat{x} + (e+g)\hat{y} + (e+f+g+h)}
\]
as $\hat{x}, \hat{y}$ range independently from \emph{zero} to infinity. If the denominator cannot be zero, the floor is always
between the minimum and maximum of
\[
\left\{ \frac{a}{e},\frac{a+b}{e+f},\frac{a+c}{e+g},\frac{a+b+c+d}{e+f+g+h} \right\}
\]
where we may ignore fractions with numerator and denominator both zero.

When the floor (i.e. the next term of output) is known, we produce output $z_j=k$ and the next bihomographic expression is
\[
\left(\frac{axy + bx + cy + d}{exy + fx + gy + h} - k\right)^{-1} = \frac{exy + fx + gy + h}{(a-ke)xy + (b-kf)x + (c-kg)y + (d-kh)}
\]
so we define the corresponding operation on matrices
\[
\mbox{produce}(k, \abcd) = \bihomographic{e}{f}{g}{h}{(a-ke)}{(b-kf)}{(c-kg)}{(d-kh)}
\]
 If the floor is not determined (in particular when the denominator might be zero), we must narrow the range by ingesting the next term of either $x$ or $y$.
 If we use $x = [s,x_{k+1},x_{k+2}\cdots]$, we make the substitution $x \leftarrow s + 1/x$ to get
\[
\frac{(sa+c)xy + (sb+d)x + ay + b}{(ae+g)xy + (af+h)x + ey + f}
\]
so we define
\[
\mbox{ingest\_x}(s, \abcd) = \bihomographic{(sa+c)}{(sb+d)}{a}{b} {(ae+g)}{(af+h)}{e}{f}
\]
with the analogous 
\[
\mbox{ingest\_y}(s, \abcd) = \bihomographic{(sa+b)}{a}{(sc+d)}{c}{(se+f)}{e}{(sg+h)}{g}
\]
for the result of substituting $y \leftarrow s + 1/y$.

If one or both inputs are rational, we will eventually ingest infinity, which we define by taking the limit. In most cases
\[
\mbox{ingest\_x}(\infty, \abcd) = \bihomographic{0}{0}{a}{b} {0}{0}{e}{f}
\]
\[
\mbox{ingest\_y}(\infty, \abcd) = \bihomographic{0}{a}{0}{c}{0}{e}{0}{g}
\]
except that this definition of $\mbox{ingest\_x}$ is valid only when the numerator and denominator both contain $x$ terms
(i.e. only if $a,b$ are not both zero and $e,f$ are not both zero), with an analogous requirement for $\mbox{ingest\_y}$.
If the matrix is of the form $\frac{bx+d}{fy+h}$ then the limit as $x \to \infty$ is infinity, %(with a similar observation for $\frac{cy+d}{h}$),
and the limit as $y \to \infty$  is zero. 
For some bihomographic matrices the limit is not an expression of the same type, but this only occurs when we divide by zero; see section \ref{sec:anomalous}.

\begin{figure}\label{fig:twoCFarithPrelim}
\begin{algorithmic}
\STATE{$i \gets 0$} \COMMENT{index of the next term of $x$ and $y$ we will read}
\STATE{$j \gets 0$} \COMMENT{index of the next term of $z$ we will generate}
\STATE{$M \gets \abcd$} \COMMENT{the initial matrix, i.e. the expression whose CF we will compute}
\STATE{$M \gets \mbox{ingest\_y}(y_0, \mbox{ingest\_x}(x_0, M))$}
\STATE{$i \gets 1$}
\WHILE {$M \neq \infty$} 
	\WHILE{$\mathcal{R}(M)$ is not a singleton}
                   \STATE{$M \gets \mbox{ingest\_y}(y_i, \mbox{ingest\_x}(x_i, M))$}
                   \STATE{$i \gets i+1$}
           \ENDWHILE
           \STATE{$z_j \gets \mathcal{R}(M)$}
          \STATE{$M \gets \mbox{produce}(z_j,M)$}
          \STATE{$j \gets j+1$}
\ENDWHILE
\end{algorithmic}
\caption{Preliminary algorithm for arithmetic on two CFs}
\end{figure}

We now have a preliminary algorithm for arithmetic, which is essentially the original algorithm of Gosper in more explicit notation. 
This algorithm will in fact require substantial modification, but we include it as a summary
of the key ideas. It is not much different from the single-CF case. Computations of $x+y, x-y,xy$, and $x/y$ begin with matrices
$\bihomographic{0}{1}{1}{0}{0}{0}{0}{1}, \bihomographic{0}{1}{-1}{0}{0}{0}{0}{1},
\bihomographic{1}{0}{0}{0}{0}{0}{0}{1}$ and $\bihomographic{0}{1}{0}{0}{0}{0}{1}{0}$.

Note that it is not at all necessary to ingest terms of both inputs in lockstep as we have here;
Gosper suggests heuristics for accelerating the algorithm by choosing the input term most likely to get us to the next production step
more quickly. This appears to be a worthwhile subject for further work.

It is interesting that the algorithms for all arithmetic operations are identical, except for the initial $M$. The reason, one might say, is
that division is the hardest arithmetic operation, and the definition of continued fractions has division built-in to everything.


\subsection{Division by Zero}\label{sec:anomalous}
The limit of $\frac{axy + bx + cy + d}{exy + fx + gy + h}$ as $x$ or $y$ approaches infinity is not necessarily a homographic matrix; for example
\[
\lim_{y \to \infty} \frac{y}{x-3} = \begin{cases}
                                                          +\infty & \mbox{if } x > 3 \\
                                                          \mbox{undefined} & \mbox{if } x=3 \\
                                                          -\infty & \mbox{if } x < 3
                                                         \end{cases}
\]
But ingesting infinity can only mean that we have reached the end of a finite rational input $\mathbf{y}$. At a previous step we
must have ingested a term $\alpha$. The previous matrix, which generated $\frac{y}{x-3}$ by substituting $y \leftarrow \alpha + 1/y$, can be found by applying the inverse substitution $y \leftarrow 1/(y-\alpha)$ to get
\[
\frac{1}{(y-\alpha)(x-3)} = \frac{1}{xy - \alpha x -3y +3\alpha}
\]
which means we are trying to divide by zero; the invalid computation is revealed by the anomalous limit.
Examination of cases shows that such anomalous limits can only arise from division by zero.


\subsection{Failure to Converge}
Our preliminary algorithm demonstrates the basic idea of CF arithmetic, but is insufficient because it can fail to converge;
we might endlessly ingest terms of both $x$ and $y$ without ever obtaining a bihomographic expression whose floor is known. The
simplest case is multiplying $\sqrt{2} = [1,(2)]$ by itself. The first iteration, ingesting 1 from $x$ and from $y$, gives
\begin{equation*}
z = \sqrt{2}*\sqrt{2} = [z_0,z_1, \cdots] = \frac{xy+x+y+1}{xy} \ . %\bihom{1}{1}{1}{1}{1}{0}{0}{0} \ .
\end{equation*}
Repeatedly ingesting 2 from both $x$ and $y$ yields
\begin{equation}\label{eq:bound2}
[z_0,z_1, \cdots]  =  \bihom{9}{3}{3}{1}{4}{2}{2}{1}
\end{equation}
\begin{equation}\label{eq:bound3}
[z_0,z_1, \cdots]  =  \bihom{49}{21}{21}{9}{25}{20}{10}{4}
\end{equation}
\begin{equation}\label{eq:bound4}
[z_0,z_1, \cdots]  =  \bihom{289}{119}{119}{49}{144}{60}{60}{25}
\end{equation}
and so on. The matrix (\ref{eq:bound2}) takes values ranging from $\frac{16}{9}$ to $\frac{9}{4}$ (i.e. 1.777 to 2.25)
as $x$ and $y$ range from one to infinity;
similarly matrix (\ref{eq:bound3}) is between $\frac{49}{25}$ and $\frac{100}{49}$ (i.e. 1.96 to 2.0408).
And the last ranges from $\frac{576}{289}$ to $\frac{289}{144}$, which is about 1.993 to 2.00694.

The source of the problem is now clear: we should have $z=[z_0,z_1]=[2,\infty]$, but no finite number of terms can ever tell us that
$z_0=2$. It is always possible that one input is in fact less than $\sqrt{2}$, so it is always possible that $z<2$ and $z_0=1$.

Our approach to the problem (see \cite{Lester01} for an entirely different approach)
applies basic notions from interval arithmetic (\cite{doi:10.1137/1.9780898717716,Mayer+2017}).
We separate the internal representation of a CF as a data structure from the mathematical notion of a  sequence of integer terms. The
internal representation will contain explicit terms (i.e. $z_k=n$) whenever such can be determined, but might also contain arbitrary
bounds on the tail $[z_k, z_{k+1}\cdots]$, such as the  sequence of bounds we derived for $\sqrt{2}*\sqrt{2}$. This is a direct
generalization, because the explicit term  $z_k=n$ is equivalent to the bound 
\[
n \leq [z_k, z_{k+1}\cdots] < n+1 \ .
\]
Therefore, when a CF is constructed explicitly from a known sequence of integer terms $[a_0, a_1, \cdots]$,
it will be represented internally as the sequence of half-open intervals
\[
[[a_0, a_0+1),  [a_1, a_1+1), \cdots]\ .
\] 
At the opposite extreme, the internal representation for $\sqrt{2}^2$ will consist entirely of ever-tighter bounds on the first term, i.e. the sequence of nested intervals
\[
[[\frac{16}{9},\frac{9}{4}), [\frac{49}{25},\frac{100}{49}), [\frac{576}{289},\frac{289}{144}), \cdots]\ .
\] 

The general idea (elaborated more fully in section \ref{sec:finalAlgorithm}) is that we will generate output on \emph{every}
 iteration of the arithmetic algorithm; when we cannot produce the next term of $z$, we output upper and lower bounds on the current
 homographic matrix, leaving the matrix unchanged. Reading such output, there can be no ambiguity about the term to which a bound 
 applies; the first bound applies to $z_0$, and as soon as we encounter an explicit term $[a,a+1)$ we know that $z_k=n$ and the next bound will apply to $z_{k+1}$. 
 This implies that any finite prefix of the output sequence will determine a finite prefix $[z_0 \cdots z_{k-1}]$ of the actual CF, followed by a bound
 $[\ell_k,u_k)$ on the tail $[z_k, z_{k+1}\cdots]$. The exact value of the CF is between $[z_0 \cdots z_{k-1}, \ell_k]$ and
 $[z_0 \cdots z_{k-1}, u_k]$; here we extend the usual CF notation by allowing a rational number, instead of an integer, as the last term.

Note that storage of a long sequence of intervals is not an issue for implementation;
successive bounds on the same term are always tighter, so there is no need to retain earlier bounds when a new one is obtained. 

\subsection{Extracting Terms}
We must note that our representation of CF arithmetic makes it impossible to simply ask a question like ``what are the first
five terms of $z = xy$?" An explicit list of terms can only be relative to a required degree of accuracy $\varepsilon$. Our arithmetic
algorithms consume and return theoretically infinite sequences of intervals; extracting a finite sequence of terms is a separate
``post-processing" step, carried out only when a numerical approximation is required.
To obtain such an approximation, we find a prefix of
the output interval sequence which is long enough to make the difference between $[z_0 \cdots z_{k-1}, \ell_k]$ and $[z_0 \cdots
z_{k-1}, u_k]$ less than $\varepsilon$; then our approximate CF is $[z_0 \cdots z_k]$, where $z_k$ is some integer in the interval
$[\ell_k,u_k)$. We might as well always take $z_k = \lfloor u_k \rfloor$, which is the only integer in the interval if the interval is small. 

In the case of $\sqrt{2}^2$, any accuracy threshold will yield the same result, $z = [2]$.


\subsection{An Algorithm for CF Arithmetic}\label{sec:finalAlgorithm}
We now present the full details of the algorithm suggested in the previous section.  We augment the matrix $M$ with a pair of intervals
$\{I_x, I_y\} = \{[x_{\ell},x_{u}), [y_{\ell}, y_{u})\}$, the current bounds on the remaining tails of the inputs $x,y$. These
intervals start at $(-\infty, \infty)$, since the first term could be any integer. When we read an interval of the form $[a,a+1)$ from
$x$ or from $y$, we modify $M$ as before with $M \leftarrow \mbox{ingest\_x}(a,M)$ or $M \leftarrow \mbox{ingest\_y}(a,M)$,
and we change that variable's bound to $[1, \infty)$. When we read an \emph{ambiguous} interval $[\ell, u)$ (i.e. a bound that
does not determine the next term of the input), we replace the bound $I_x$ or $I_y$  with $[\ell, u)$, leaving $M$ unchanged.

For output, we first redefine $\mathcal{R}(M)$ to take the bounds into account, i.e.
\[
\mathcal{R}\left(\abcd, I_x, I_y\right) = \left\{ \left\lfloor \bihom{a}{b}{c}{d}{e}{f}{g}{h} \right\rfloor | \  x \in I_x, y \in I_y \right\}
\]
When this is a singleton set $\{a\}$, we output $[a,a+1)$ and modify $M$ as before with $M \leftarrow \mbox{produce}(a,M)$;
the intervals $I_x$ and $I_y$ do not change. Otherwise we leave $M$ unchanged and output the interval from min to max of $M(x,y)$ subject to $x \in I_x, y \in I_y$:
denote this interval $\rho\left(\abcd, I_x, I_y\right)$.
These bounds are easily computed, see section (\ref{sec:ComputeBounds}).
To retain unlimited accuracy, the bounds must be computed with exact rational arithmetic.

\subsubsection{Recursive Definition}
Figure (\ref{fig:twoCFarith}) presents the arithmetic algorithm as imperative pseudocode. We can also write it as a recursive function,
which is essentially the same as our Haskell implementation.
We first define versions of $\mbox{ingest\_x},\mbox{ingest\_y}$ that consider the bounds on $x$ and $y$. Given an unambiguous input interval,
\[
\mbox{ingestBound\_x}([s,s+1), M, I_x, I_y) = 
(\mbox{ingest\_x}(s,M), (1,\infty),I_y)
\]
while for an ambiguous interval
\[
\mbox{ingestBound\_x}(I_0, M, I_x, I_y) = 
(M, I_0,I_y)
\]
with a similar definition for \mbox{ingestBound\_y}.
We use the standard notation $x\:x_s$ to denote the head and tail of a list. 
If $x,y = x_0\:x_s, y_0\:y_s$ are lists of intervals and $M$ is bihomographic, we define
\[
\mbox{arith}(x,y, M, I_x, I_y)
\]
to be
\[
(a,a+1)\:\mbox{arith}(x,y,  \mbox{prod}(a,M) ,  I_x,  I_y)
\]
if $\rho(M,I_x,I_y)$ determines $a$ as the next output term, and
\[
\rho(M,I_x,I_y)\:\mbox{arith}(x_s,y_s,  \mbox{ingestBound\_y}( y_0, (\mbox{ingestBound\_x}(x_0,M,I_x,I_y)) ))
\]
otherwise. If $M=\infty$ (i.e. the denominator is zero), we have exhausted a pair of rational inputs to produce a rational result, and can terminate the recursion with $\mbox{arith}(x,y, M, I_x, I_y) = [\infty]$.

%\subsubsection{Correctness of the Algorithm} The arithmetic algorithm cannot stall, since every iteration appends a new bound to the output list. If the algorithm generates an infinite list of ambiguous bounds, we can see immediately that these will converge to $M(x,y)$.

\begin{figure}\label{fig:twoCFarith}
\begin{algorithmic}
\STATE{}\COMMENT{input $x,y$: CFs represented as lists of intervals}
\STATE{}\COMMENT{input $M$: bihomographic matrix}
\STATE{}\COMMENT{output $z$: CF expansion of $M(x,y)$, represented as a list of intervals}
\STATE{$i \gets 0$} \COMMENT{index of the next element of $x$ and $y$ we will read}
\STATE{$j \gets 0$} \COMMENT{index of the next element of $z$ we will generate}
\STATE{$I_x,I_y \gets (-\infty, \infty),(-\infty, \infty)$} \COMMENT{current bounds on remaining parts of $x,y$}
\WHILE {$M \neq \infty$}
    \STATE{}\COMMENT{read input}
     \IF{$x_i = [a,a+1)$ (where $a$ is an integer)} 
         \STATE{$M \gets \mbox{ingest\_x}( a, M)$}
         \STATE{$I_x \gets [1,\infty)$}
     \ELSE    
          \STATE{$I_x \gets x_i$}
     \ENDIF
          \IF{$y_i = [a,a+1)$ (where $a$ is an integer)} 
         \STATE{$M \gets \mbox{ingest\_y}( a, M)$}
         \STATE{$I_y \gets [1,\infty)$}
     \ELSE    
          \STATE{$I_y \gets y_i$}
     \ENDIF
     \STATE{$i \gets i+1$}
     
     \STATE{}\COMMENT{produce output}
     \IF{$\mathcal{R}(M,I_x,I_y)$ is a singleton set $\{a\}$}
     \STATE{$M \gets \mbox{produce}(a, M)$}
          \STATE{$z_j \gets [a,a+1)$}    
     \ELSE
         \STATE{$z_j \gets \rho(M,I_x, I_y)$}
     \ENDIF
     \STATE{$j \gets j+1$}
\ENDWHILE
\end{algorithmic}
\caption{Algorithm for arithmetic on two CFs (without optimizations)}
\end{figure}


\subsection{Computing the range of $M$}\label{sec:ComputeBounds}
To compute $\rho\left(\abcd, [x_{\ell}, x_u),  [y_{\ell}, y_u)\right)$:
\begin{itemize}
\item Let $\delta_x, \delta_y = x_u - x_{\ell}, y_u - y_{\ell}$
\item Substitute $x \leftarrow x_{\ell} + \frac{\delta}{x'+1}$ and $y \leftarrow y_{\ell} + \frac{\delta}{y'+1}$.
Now $x$ goes from $x_{\ell}$ to $x_u$ as $x'$ goes from 0 to infinity, similarly for $y,y'$
\item Let the coefficients of the resulting matrix be $\bihomographic{a'}{b'}{c'}{d'}{e'}{f'}{g'}{h'}$
\end{itemize}
The range of $M$ subject to the bounds will be the min and max of 
\[
\left\{ \frac{a'}{e'},\frac{b'}{f'},\frac{c'}{g'},\frac{d'}{h'} \right\}
\]
assuming no sign change in the denominator as $x'$ goes from 0 to infinity; fractions with numerator and denominator both $0$ can be ignored.


\subsection{Possible Optimization}
When we have to read the next interval from $x$ or $y$, and we see an ambiguous interval at the head of the list, it is not necessary
to use that interval; we may skip it and go on to the next element of the list, which will give a tighter bound on the next term.
Any such heuristic must guarantee that, given an infinite list of ambiguous input intervals, we eventually read something
and recompute the range of $M$. Similarly, the
algorithm does not need to output every ambiguous interval of $z$; but  we must guarantee that we eventually output something,
even if we are generating an infinite list of ambiguous intervals. The most obvious idea is to read and generate ambiguous intervals only if the gap is smaller than some threshold.


\section{Solving Quadratic Equations}
\subsection{Square root of a rational number}
The arithmetic algorithm can be extended to solve quadratic equations with CF coefficients.
We begin with the special case of computing the square root of a rational number $\alpha$. 
The key idea is that $\sqrt{\alpha}$ is the \emph{fixed point} of a homographic function, i.e. the solution to
\[
y = \frac{\alpha}{y}\ .
\]
We thus need to find a continued fraction $y$ which produces $y$ given the initial matrix
$\left(\begin{smallmatrix}
0 & p \\
q & 0
\end{smallmatrix}\right)$, where $\alpha = \frac{p}{q}$.

As a concrete example, we find $\sqrt{11}$. The first term will be the floor of the fixed point of 
$M = \left(\begin{smallmatrix}
0 & 11 \\
1 & 0
\end{smallmatrix}\right)$. It is easy to observe in this case that $M(3)>3$ and
$M(4)<4$, so the first term is $y_0=3$; but we must find a better algorithm than linear search through
$M(1), M(2), M(3)\cdots$. We can make use of the fact that any homographic function of the form
 \[
 M = \begin{pmatrix}
p & q \\
r & -p
\end{pmatrix}
\]
 is \emph{self-inverse}: i.e. $M(M(y)) = y$. This immediately implies that,
given any $\hat{y}$, the fixed point is between $\hat{y}$ and $M(\hat{y})$.
So we can use binary search to find the desired term.
Search can begin with the smallest positive integer greater than the root of the denominator, $\frac{p}{r}$.
In fact, the self-inverse property implies the existence of an integer $\hat{y}$ such that $\hat{y} = \lfloor M(\hat{y}) \rfloor$ or $\hat{y} = 1 + \lfloor M(\hat{y}) \rfloor$; in either case $\lfloor M(\hat{y}) \rfloor$ is the next term of $y$. 
The self-inverse property is preserved by ingesting and then producing the same term:
\[
\mbox{produce}\left(\hat{y}, \mbox{ingest}\left(\hat{y},   \left(\begin{smallmatrix}
p & q \\
r & -p
\end{smallmatrix}\right)\right)     \right) = 
\left(\begin{smallmatrix}
 \hat{y}r-p              & r  \\
q+2\hat{y}p-\hat{y}^2r & p-\hat{y}r
\end{smallmatrix}\right)\ .
\]
Thus each subsequent iteration can be handled the same way. After $y_0=3$ we obtain
\[
M= \begin{pmatrix}
3 & 1 \\
2 & -3
\end{pmatrix}
\]
which yields $y_1=3$ since now $M(3)=\frac{10}{3}$. Ingesting and producing 3 leads to
\[
M= \begin{pmatrix}
3 & 2 \\
1 & -3
\end{pmatrix}
\]
implying $y_2=6$ because $M(6)=\frac{20}{3}$. The next iteration puts us in a loop: ingesting
and producing 6 takes us back to 
\[
 \begin{pmatrix}
3 & 1 \\
2 & -3
\end{pmatrix}
\]
proving that $\sqrt{11} = [3, (3,6)]$.


\subsection{Square root of an explicit CF}
Now we consider how to extract the square root of a real number $x$ given as a continued fraction. We will start 
with the simpler case in which $x$ expressed as an explicit list of integer terms, before generalizing to an algorithm that
operates on our internal representation of a CF as a list of intervals.

The square root of $x$ is the fixed point $y = \frac{x}{y}$. The matrix $\left(
\begin{smallmatrix} 
0 & 1 & 0 & 0\\ 
0 & 0 & 1 & 0
\end{smallmatrix}
\right)$
is bihomographic, but we can also think of it as a homographic
matrix $\left(
\begin{smallmatrix} 
0 & x \\ 
1 & 0 
\end{smallmatrix}
\right)$ with constant $x$ and variable $y$. More generally let $M_{\mathbf{x}}$ denote $M$ with $x$ fixed at $\mathbf{x}$,
i.e. if $M=\abcd$ then
\[
M_{\mathbf{x}} = \begin{pmatrix}
                                (a\mathbf{x}+c) & (b\mathbf{x}+d)\\
                                (e\mathbf{x}+g) & (f\mathbf{x}+h)
                                \end{pmatrix}\ .
\]
As before, we use boldface $\mathbf{x}$ to distinguish a specific input from the symbolic variable. $M_{\infty}$ is the limit $\left(
\begin{smallmatrix} 
a & b \\ 
e & f 
\end{smallmatrix}
\right)$.

Starting from $\left(
\begin{smallmatrix} 
0 & 1 & 0 & 0\\ 
0 & 0 & 1 & 0
\end{smallmatrix}
\right)$, we must ingest terms of $\mathbf{x}$ until we reach a stage at which the floor of the fixed point does not depend on $x$;
in other words, until the floor of the fixed point is the same when $x=1$ and $x=\infty$. This floor will be the next term of $y$.
To find the next term, we first use binary search to get $\hat{y}$, the floor of the fixed point of of $M_1$; 
then we check whether $\hat{y}$ is also the floor of the fixed point of  $M_{\infty}$. If so, we ingest
$\hat{y}$ and produce $\hat{y}$; if not, we ingest another term of $\mathbf{x}$ and continue.

This works because the matrices $M_x$ will always have the self-inverse property. Such is clearly the case with the initial matrix, and a
 similar computation to what we did for rational $\mathbf{x}$ proves the property is preserved when we ingest and produce a term.

As an example, we compute the fourth root of 2, i.e. the square root of $\mathbf{x} = [1,(2)]$.
Making the substitution $x \leftarrow 1 + \frac{1}{x}$ gives
\[
M = \frac{x+1}{xy}\ .
\]
The fact that $\lfloor \mathbf{x} \rfloor = 1$ should be enough to imply that $\lfloor y \rfloor = 1$, and indeed this is the case:
\begin{equation*}
\begin{array}{cc}
M_1 = \frac{2}{y} & M_\infty = \frac{1}{y} \\
M_1(1) = 2 & M_\infty(1) = 1
\end{array}
\end{equation*}
Ingesting and producing $y_0=1$ leads to $M=\frac{yx+x}{y-x}$; then ingesting 2 from $\mathbf{x}$ gives
\[
M = \frac{2xy + 2x + y + 1}{xy -2x -1}\ .
\]
We do not yet have enough information to determine the next output term:
\begin{equation*}
\begin{array}{cc}
M_1 = \frac{3y+3}{y-3} & M_\infty = \frac{2y+2}{y-2} \\
M_1(6) = 7 & M_\infty(5) = 4 
\end{array}
\end{equation*}
Ingesting another 2 from $\mathbf{x}$ will suffice:
\[
M = \frac{5xy+5x+2y+2}{2xy-5x+y-2}
\]
and
\begin{equation*}
\begin{array}{cc}
M_1 = \frac{7y+7}{3y-7} & M_\infty = \frac{5y+5}{2y-5} \\
M_1(5) =  \frac{21}{4} & M_\infty(5) =  5
\end{array}
\end{equation*}
so $y_1=5$. After ingesting/producing 5 and then reading another 2 from $\mathbf{x}$ we reach
\[
M = \frac{13xy+5x+5y+2}{7xy-13x+5y-5} 
\]
which tells us that $y_2=3$: $M_1(3)=\frac{61}{18}$ and $M_\infty(4)=\frac{19}{5}$. 
The first few terms of $\sqrt[4]{2}$ are $1.18921\cdots = [1,5,3,1,1,40,5,\cdots]$.

\begin{figure}\label{fig:sqrtCF}
\begin{algorithmic}
\STATE{}\COMMENT{input $x$: CF represented as a list of intervals}
\STATE{}\COMMENT{output $y$: CF expansion of $\sqrt{x}$, represented as a list of intervals}
\STATE{$i \gets 0$} \COMMENT{index of the next element of $x$ we will read}
\STATE{$j \gets 0$} \COMMENT{index of the next element of $y$ we will generate}
\STATE{$(x_{\ell},x_h) \gets (1, \infty)$} \COMMENT{current bounds on remaining part of $x$}
\STATE{$M=\left(
\begin{smallmatrix} 
0 & 1 & 0 & 0\\ 
0 & 0 & 1 & 0
\end{smallmatrix}
\right)$} \COMMENT{solve $y = \frac{x}{y}$}
\WHILE {$M \neq \infty$}  
   \WHILE{floor of fixed point of $M_{x_h}$ does not equal floor of fixed point of $M_{x_\ell}$}
      \STATE{}\COMMENT{read input}
       \IF{$x_i = [a,a+1)$ (where $a$ is an integer)}
       \STATE{$M \gets \mbox{ingest\_x}( a, M)$}
           \STATE{$(x_{\ell},x_h) \gets [1,\infty)$}
        \ELSE   
             \STATE{$(x_{\ell},x_h) \gets x_i$}
       \ENDIF
            \STATE{$i \gets i+1$}
       \ENDWHILE
     
  \WHILE{floor of fixed point of $M_{x_h}$ equals floor of fixed point of $M_{x_\ell}$}   
     \STATE{}\COMMENT{produce output}
     \STATE{$\hat{y} \gets$ floor of fixed point of $M_{x_{\ell}}$}
        \IF{$\hat{y}<1$}
          \STATE{$y_j \gets \infty$}
          \STATE{exit}\COMMENT{see section (\ref{sec:rational})}
        \ENDIF
        \STATE{$y_j \gets [\hat{y}, \hat{y}+1)$}
        \STATE{$j \gets j+1$}
        \STATE{$M \gets \mbox{produce}(\hat{y}, \mbox{ingest\_y}( \hat{y}, M))$}
  \ENDWHILE
     
\ENDWHILE
\end{algorithmic}
\caption{Algorithm for square root of a CF}
\end{figure}


\subsection{Square root of a general CF}
The algorithm is not fundamentally different for $x$ represented as a list of intervals. When we read an ambiguous interval
$[x_\ell, x_h)$, we do not change $M$; instead we check whether the floors of the fixed points of $M_{x_\ell}$ and
$M_{x_h}$ are the same. If so, this common value is the next term of $y$.

To simplify the algorithm we have assumed that all terms of $x$, including the first term, are greater than or equal to 1. The case of $x_0=0$ is easily handled: if $x = [0,x_1,x_2,\cdots]$ then $\sqrt{x} = [0,z_0,z_1,\cdots]$ where $z = \sqrt{[x_1,x_2,\cdots]} = \sqrt{1/x}$.


\subsection{Algorithm Termination}
It is possible for the square-root algorithm to stall, reading infinitely many terms from $\mathbf{x}$ without ever determining the next term of $y$.
Suppose that the true fixed point of $M_\mathbf{x}$ is an integer $k$; as we ingest more terms from $\mathbf{x}$, the fixed points of $M_{x_\ell}$ and $M_{x_h}$ will both approach  $k$, but the floor of one fixed point will be $k$ and the floor of the other will be $k-1$.
We cannot guarantee that a finite number of terms of $\mathbf{x}$ will ever determine $y_i=k$.
This would happen, for instance, if we tried to compute the square root of 4, if 4 were given not as $x=[4,\infty]$, but instead as an infinite sequence of ambiguous terms approaching 4.

The solution is the same as in the case of arithmetic; we can output ambiguous terms of $y$. Let $\phi(M)$ denote the fixed point of $M$; we would like to output $y_i = (\phi(M_{x_\ell}), \phi(M_{x_h}))$. This does not quite work, since the bounds can be irrational, so we must instead define rational bounds ${\phi_\ell}'(M_{x_\ell}) \leq \phi(M_{x_\ell}), {\phi_h}'(M_{x_h}) \geq \phi(M_{x_h})$;  these bounds must be tight enough to guarantee convergence. We can find approximate rational bounds with binary search.

Note that stalling cannot happen if $\mathbf{x}$ is irrational, since the fixed point will never be integral; $\phi(M_{x_\ell})$ and $\phi(M_{x_h})$ will approach a non-integral limit, and after a finite number of steps, the floors of the fixed points will be the same.


\subsection{Further Implementation Details}\label{sec:rational}
We must take some care in considering the fixed point of $M_\infty$. In our computation of $\sqrt[4]{2}$, we obtained 
 $M=\frac{yx+x}{y-x}$ after ingesting $x_0=1$ and then ingesting/producing $y_0=1$.
 At this point, rather than immediately ingesting $x_1=2$, we might see if we can get another term of $y$ from $M$. We have
 \begin{equation*}
\begin{array}{cc}
M_1 = \frac{y+1}{y-1} & M_\infty = \frac{y+1}{-1}\ . \\
\end{array}
\end{equation*}
The fixed point of $M_1$ is between 2 and 3, but the fixed point of $M_\infty$ is negative. What is going on?
$M_\infty$ is the limit as $x \to \infty$ for any fixed $y$, but in this case the fixed point of $M_x$ approaches infinity as $x \to \infty$, leading to the invalid result.
At this point we may validly generate $[\alpha,\infty)$ as a bound on $y_1$, where $\alpha$ is any rational lower bound on the fixed point of $M_1$; for instance $\alpha = 2$ would be correct.
 
A similar issue arises in the case where $y$ is in fact a rational number,
i.e. a finite continued fraction. Suppose we apply our algorithm to get the square root of 9, i.e. $x = [9,\infty]$.
After making the initial substitution $x \leftarrow 9 + \frac{1}{x}$, then ingesting/producing $y_0=3$,
we will be seeking the fixed point
\begin{equation}\label{eq:sqrt9}
y = \frac{3xy+x}{-3x+y}\ .
\end{equation}
Note that (\ref{eq:sqrt9}) is simply a rearrangement of $3+\frac{1}{y} = \sqrt{9+\frac{1}{x}}$, i.e. of
\[
3+\frac{1}{y} = \frac{9+\frac{1}{x}}{3+\frac{1}{y}}\ .
\]
Written this way it is obvious that $y$ approaches infinity as $x$ approaches infinity. After ingesting $x=\infty$, the variable $x$ disappears and we will be trying to solve
\[
y = \frac{3y+1}{-3}\ .
\]
Now $M_1$ and $M_\infty$ must be the same; with $x$ gone, both matrices are just
$\left(
\begin{smallmatrix} 
3 & 1 \\ 
0 & -3 
\end{smallmatrix}
\right)$. The fixed point is $y=-1/6$, again meaning that in fact the fixed point goes to infinity as $x$ does; so we terminate the computation with $y_1 = \infty$.


\subsection{Quadratic equations}
A quadratic equation can be written as the fixed point of a self-inverse homographic function:
$
py^2 + qy + r = 0
$
is equivalent to
\begin{equation}\label{eq:cfQuadratic}
y = \frac{-qy - 2r}{2py + q}\ .
\end{equation}
If $q$ is given as a continued fraction, we can solve (\ref{eq:cfQuadratic}) by starting with $M= \left(
\begin{smallmatrix} 
-x & -2r \\ 
2p & x 
\end{smallmatrix}
\right)$ and finding the fixed point, ingesting terms of  $q=\mathbf{x}$. The cases of $p$ or $r$ as continued fractions are similar.
Computationally, this should be faster than direct application of the quadratic formula, which would require multiple arithmetic operations as well as a square root.


\section{Arithmetic with Arbitrary Intervals}
In the algorithm for CF arithmetic, all intervals are either ambiguous (i.e. there is an integer in the interior of the interval), or are of the form $[a,a+1)$ for integer $a$. But this potentially throws away information.
Whenever we are able to produce an explicit output term $z_j \leftarrow [a,a+1)$, we in fact know that the tail 
\[
a + \frac{1}{[z_{j+1}, z_{j+2},\cdots]}
\]
lies in the possibly smaller interval $\rho(M,I_x, I_y)$, and can set $z_j \leftarrow \rho(M,I_x, I_y)$.

If we generate such intervals as output then we must be able to read them as input. If $x_i = (a+\varepsilon_\ell, a+\varepsilon_u)$, we can ingest $x=a$ into $M$, and set $I_x \leftarrow (\varepsilon_u^{-1}, \varepsilon_\ell^{-1})$ instead of $I_x \leftarrow [1,\infty)$. This will yield a narrower range for $z_j$.

In the same manner, suppose the current (ambiguous) bound on $x$ is $I_x = (x_{\ell}, x_{h})$, and we read an explicit term $x_i = [a,a+1)$. After ingesting $a$ into the matrix, we need not set $I_x = [1,\infty)$; we may set
\[
I_x = \left(\frac{1}{\min(x_h,a+1) - a}, \frac{1}{\max(x_{\ell},a) - a}\right) \ .
\]

Of course there is no guarantee that the more precise representation would give any computational advantage in practice, since more computation is required to manipulate the tighter bounds.


\section{Taylor Series}
\subsection{Exponentials} We now consider how to compute the CF terms of 
\[
e^x = \sum_{k=0}^{\infty} \frac{x^k}{k!}
\]
where $x$ is given as a CF. Let
\[
M_{(n,x)}(y) = 1 + \frac{xy}{n} \ .
\]
This is a bihomographic expression with matrix $\bihomographic{1}{0}{0}{n}{0}{0}{0}{n}$. The $n^{th}$ degree Taylor approximation,
$1 + x + x^2/2 +\cdots + x^n/{n!}$, can be written using Horner's rule as
\[
 1 + x \left(1 + \frac{x}{2}\left( 1 + \frac{x}{3}\left(1 + \cdots \left(1 + \frac{x}{n}\right)\right)\right) \cdots \right) = M_{(1,x)}( M_{(2,x)}( \cdots M_{(n,x)}(1) \cdots ) ) \ . \]
 Let us assume, temporarily, that $|x| \leq 1$. Now define
 \[
 y_n(x) = 1 + \frac{x}{n} + \frac{x^2}{n(n+1)} + \cdots = \lim_{m\to\infty} M_{(n,x)}( M_{(n+1,x)}( \cdots M_{(m,x)}(1) \cdots ) ) \ .
  \]
 Comparing termwise we see that
 \[
 |y_n(x) - 1| \leq \frac{|e^x - 1|}{n} \ .
 \]
Since $\frac{1}{3} < e^x < 3$, we know that $y_n(x)$ is in the interval $(1 - \frac{2}{3n}, 1 + \frac{2}{n})$, so this can be the first (necessarily ambiguous) term of the CF representation of $y_n(x)$.
The subsequent terms are the CF representation of $M_{(n,x)}(y_{n+1}(x))$, which is a bihomographic expression that can be evaluated with the arithmetic algorithm. We then have $e^x = y_1(x)$. The infinite recursion does not lead to an infinite loop, since we can always get one term of $y_n(x)$ without recursion into $y_{n+1}(x)$; at some point this one term will be sufficient to determine the next output.

If $|x|>1$, we could use the weaker bound $0 < e^x < 3^{\lceil x \rceil}$. Or we could take advantage of the fact that there is an explicit formula for the CF expansion of $e$:
\[
e = [1,2,1,1,4,1,1,6,1,1,8,1,1,10,1 \cdots ]
\]
and write $e^x$ as $e^{\lfloor x \rfloor}e^{x-\lfloor x \rfloor}$, using ordinary multiplication to obtain $e^{\lfloor x \rfloor}$. In either case, the floor or ceiling of $x$ can be obtained from a finite prefix of $x$.


\subsection{Logarithms} We can apply the same approach to $\log x$, using the series
\[
\log (x) =  2 \left( \left(\frac{x-1}{x+1}\right) + \frac{1}{3}\left(\frac{x-1}{x+1}\right)^3 + \frac{1}{5}\left(\frac{x-1}{x+1}\right)^5 \cdots \right)
\]
which converges for all $x > 0$. Let $z=\frac{x-1}{x+1}$ and $w=z^2$, and define
\[
g(w) = 1 + \frac{w}{3} + \frac{w^2}{5} + \frac{w^3}{7} + \cdots = \left(1 + w\left(\frac{1}{3} + w\left(\frac{1}{5} \cdots \right. \right. \right. \ .
\]
Then $\log x = 2zg(w)$, so we only need consider how to compute $g(w)$, where $0 \leq w \leq 1$.
In the same manner as the previous section, the series for $g(w)$ can be obtained by iterating
\[
M_{(n,w)}(y) = \frac{1}{2n-1} + wy 
\]
i.e. the bihomographic expression $\bihomographic{2n-1}{0}{0}{1}{0}{0}{0}{2n-1}$.
So we define
\[
y_n(w) = \frac{1}{2n-1}  + \frac{w}{2n+1} + \frac{w^2}{2n+3} \cdots = \lim_{m\to\infty} M_{(n,w)}( M_{(n+1,w)}( \cdots M_{(m,w)}(1/2m+1) \cdots ) ) \ .
\]
Since $w$ is nonnegative, we know that $y_n(w) \geq \frac{1}{2n-1}$. The upper bound, however, goes to infinity as $w$ approaches 1, i.e. as $x$ approaches zero or infinity. So let us assume temporarily that $1<x<e$; then 
\[
|z| \leq \frac{e-1}{e+1} < \frac{3-1}{3+1} = \frac{1}{2}
\]
and $w < \frac{1}{4}$, implying $y_n(w) < \frac{4}{3(2n-1)}$.
We can take $(\frac{1}{2n-1}, \frac{4}{3(2n-1)})$ as the first interval of the CF representation of $y_n(x)$, with the following intervals obtained by applying the CF arithmetic algorithm to $M_{(n,x)}(y_{n+1}(x))$.

For other values of $x$  we can use the identities $\log(x)=1+\log(x/e)$ and $\log(x) = -\log(1/x)$ . 

\bibliographystyle{plain}
\bibliography{cfAlgorithm}

\end{document}  
